{
  "hash": "0a1c0c6bad1154546103c972cc28a554",
  "result": {
    "markdown": "---\ntitle: Keras\n---\n\nVamos ajustar um modelo exatamente igual ao que fizemos nos [exemplos 1](./01-linear-regression.html) e [2](./02-sgd.html) mas dessa vez usando o Keras.\n\n:::{.callout-note}\nO Keras é uma biblioteca que faz parte do TensorFlow e possui uma sintaxe concisa\npara definir modelos de deep learning. O TensorFlow além de ser rápido e possuir\nimplementações para GPU's, possui uma feature chamada *automatic differentiation*\nque calcular as derivadas automaticamente.\n:::\n\nOs dados estão sendo gerados da mesma forma que no [exemplo 1](./01-linear-regression.html).\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\n# Data generation ----------------------------------------------\n\nn = 1000\nx = np.random.uniform(size=(n,))\n\nW = 0.9\nb = 0.1\n\ny = W * x + b\n```\n:::\n\n\nVamos importar o Keras.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom tensorflow import keras\n```\n:::\n\n\nAgora vamos definir o modelo no Keras usando a API funcional:\nPara definir modelos usando essa API fazemos:\n\n1. Definimos o formato do nosso `input` usando a camada `keras.layers.Input`. Nesse\npasso omitimos o número de observações. O `(1,)` nesse exemplo significa que o nosso\ninput é uma matriz com `1` coluna.\n\n2. Definimos as transformações que vamos fazer no nosso input. Nesse caso usamos\na camada `keras.layers.Dense` que faz a transformação linear `W*x+ b`.\n\n3. Por fim definimos um modelo do Keras especificando um `input` e um `output`.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ninput = keras.layers.Input(shape=(1,))\noutput = keras.layers.Dense(units=1, use_bias=True)(input)\nmodel = keras.Model(inputs=input, outputs=output)\n```\n:::\n\n\nEsse modelo possui 2 parâmetros: `w` e `b`. \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel: \"model_3\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n_________________________________________________________________\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n Layer (type)                Output Shape              Param #   \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n=================================================================\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n input_4 (InputLayer)        [(None, 1)]               0         \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n                                                                 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n dense_3 (Dense)             (None, 1)                 2         \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n                                                                 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n=================================================================\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal params: 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTrainable params: 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNon-trainable params: 0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n_________________________________________________________________\n```\n:::\n:::\n\n\nEm seguida compilamos o modelo falando qual é a função de perda que queremos minimizar e\nqual o método de otimização.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nmodel.compile(\n    loss=keras.losses.mean_squared_error,\n    optimizer=keras.optimizers.SGD(learning_rate=0.01),\n)\n```\n:::\n\n\nPodemos então ajustar o modelo passando para o método `fit` os dados de `input` e\n`output`. Também especificamos um `batch_size=1` (para ficar igual ao SGD teórico)\ne o número de `epochs`. Só estamos usando `verbose=2` para a barra de prorgresso não\naparecer neste site, você pode ignorar esse parâmetro.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nhistory = model.fit(x=x, y=y, batch_size=1, epochs=5, verbose=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 1/5\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n1000/1000 - 0s - loss: 0.0015 - 489ms/epoch - 489us/step\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 2/5\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n1000/1000 - 0s - loss: 3.8309e-05 - 382ms/epoch - 382us/step\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 3/5\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n1000/1000 - 0s - loss: 2.5557e-06 - 363ms/epoch - 363us/step\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 4/5\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n1000/1000 - 0s - loss: 1.7280e-07 - 361ms/epoch - 361us/step\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 5/5\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n1000/1000 - 0s - loss: 1.1419e-08 - 365ms/epoch - 365us/step\n```\n:::\n:::\n\n\nPodemos em seguida visualizar o valor da função de perda ao longo do número de épocas:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport seaborn as sns\nsns.lineplot(x=range(5), y=history.history[\"loss\"])\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](03-keras_files/figure-html/cell-8-output-2.png){width=596 height=405}\n:::\n:::\n\n\nVisualização do grafo do modelo:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nkeras.utils.plot_model(model, show_shapes=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYou must install pydot (`pip install pydot`) and install graphviz (see instructions at https://graphviz.gitlab.io/download/) for plot_model/model_to_dot to work.\n```\n:::\n:::\n\n\nVerificar que os pesos obtidos são o mesmo que usamos apra simular os dados:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nmodel.get_weights()\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n[array([[0.89984226]], dtype=float32), array([0.10008816], dtype=float32)]\n```\n:::\n:::\n\n\nFazer previsões com o modelo ajustado:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nmodel.predict(x)[0:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\narray([[0.8098919 ],\n       [0.66679585],\n       [0.49405667],\n       [0.81630385],\n       [0.78361654]], dtype=float32)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "03-keras_files"
    ],
    "filters": [],
    "includes": {}
  }
}