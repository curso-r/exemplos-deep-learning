{
  "hash": "0946b700b40c62b3aa1437bcfd477fd7",
  "result": {
    "markdown": "---\ntitle: Convolução\n---\n\nNesse exemplo vamos mostrar o que acontece por trás dos panos quando fazemos\numa convolução no Keras.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom tensorflow import keras\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nComeçamos pegando uma imagem do banco de dados MNIST - famoso banco de dados\nde exemplos de deep learning que contém imagens de dígitos de 0 a 9 escritos à \nmão.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n(x_train, _), (_, _) = keras.datasets.mnist.load_data()\n```\n:::\n\n\nPodemos visualizar algumas imagens com:\n\n::: {.cell .column-screen-right layout-ncol='3' execution_count=3}\n``` {.python .cell-code}\nplt.imshow(x_train[0])\nplt.show()\nplt.imshow(x_train[1])\nplt.show()\nplt.imshow(x_train[2])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](06-convolution_files/figure-html/cell-4-output-1.png){width=408 height=404}\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-convolution_files/figure-html/cell-4-output-2.png){width=408 height=404}\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-convolution_files/figure-html/cell-4-output-3.png){width=408 height=404}\n:::\n:::\n\n\nCada imagem é representada por uma matrix 28x28 em que os valores são a intensidade\nde cor. Os valores vão de 0 a 255.\n\nAgora vamos definir um kernel de convolução de tamanho 3x3.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nw = np.random.uniform(size=(3, 3))\nw = np.array([[0, 0, 0], [1, 1, 1], [0, 0, 0]])\n```\n:::\n\n\nLembre-se que na convolução vamos, para cada pixel da imagem, vamos posicionar esse\nkernel e fazer a multiplicação entre ele e os vizinhos para poder somar.\n\nPrimeiro vamos definir uma forma de encontrar os vizinhos. Dado um pixel na linha 9\ne coluna doze da imagem, podemos obter os vizinhos da seguinte forma:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimg = x_train[0, :, :] / 255.0\n# vizinhança de tamanho 3x3\ni = 9\nj = 12\n\nvizinhos = img[(i - 1) : (i + 2), (j - 1) : (j + 2)]\n```\n:::\n\n\nAgora como sabemos como encontrar os vizinhos, vamos passear por todos os vizinhos\npara aplicar o algoritmo da convolução:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnew_img = img\nfor i in range(1, img.shape[0] - 1):\n    for j in range(1, img.shape[1] - 1):\n        vizinhos = img[(i - 1) : (i + 2), (j - 1) : (j + 2)]\n        # multiplica pelo kernel e soma para gerar o novo valor\n        new_img[i, j] = np.sum(w * vizinhos)\n\nnew_img = new_img[1:-1, 1:-1]\n```\n:::\n\n\nA imagem gerada depois da convolução foi:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nplt.imshow(new_img)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n<matplotlib.image.AxesImage at 0x7fb80deebd30>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-convolution_files/figure-html/cell-8-output-2.png){width=409 height=404}\n:::\n:::\n\n\nO Keras faz exatamente isso que o loop acima está fazendo quando usamos a camada\nConv2D. Vamos reproduzir a mesma imagem, agora usando o Keras. Pontos importantes:\n\n1. O kernel para o Keras é um tensor com 4 dimensões: altura e largura do kernel,\nnúmero de canais no input e número de filtros. Por isso tivemos que fazer o `reshape`.\n2. É recomendado usar ativações na convolução. Nesse exemplo não estamos usando para\npoder reproduzir o código acima.\n3. Existem diversas formas de padding. `padding='valid'` significa que não estamos\nfazendo padding, ou seja, só vamos passar pelos pixels que possuem todos os vizinhos.\n4. O parâmetro `weights` das camadas do Keras permite que você especifique os parâmetros\niniciais manualmente.\n5. Desativamos o viés também para simplificar o loop acima.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nw2 = np.reshape(w, (3, 3, 1, 1)) # o Kernel para o keras é uma array com 4 dimensões\nconv = keras.layers.Conv2D(\n    filters=1,\n    kernel_size=(3, 3),\n    activation=\"linear\",\n    padding=\"valid\",\n    weights=[w2],\n    use_bias=False,\n)\n```\n:::\n\n\nAgora aplicamos essa cada na imagem.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# o Keras espera imagens no formato (nobs, altura, largura, canais)\nim = np.reshape(img, (1, 28, 28, 1)) \nout = conv(im)\n```\n:::\n\n\nVocê pode comparar a imagem gerada pelo Keras e pelo nosso loop e verificar que são\nidênticas.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nplt.imshow(out.numpy()[0, :, :, 0])\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n<matplotlib.image.AxesImage at 0x7fb80f1455b0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-convolution_files/figure-html/cell-11-output-2.png){width=409 height=404}\n:::\n:::\n\n\n",
    "supporting": [
      "06-convolution_files"
    ],
    "filters": [],
    "includes": {}
  }
}